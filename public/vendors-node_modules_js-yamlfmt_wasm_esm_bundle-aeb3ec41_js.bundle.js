"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkweb_editor"] = self["webpackChunkweb_editor"] || []).push([["vendors-node_modules_js-yamlfmt_wasm_esm_bundle-aeb3ec41_js"],{

/***/ "./node_modules/@js-yamlfmt/wasm/esm/bundle-aeb3ec41.js":
/*!**************************************************************!*\
  !*** ./node_modules/@js-yamlfmt/wasm/esm/bundle-aeb3ec41.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// Bundled with Packemon: https://packemon.dev\n// Platform: browser, Support: stable, Format: esm\n// Copyright 2018 The Go Authors. All rights reserved.\n(() => {\n  const enosys = () => {\n    const err = new Error(\"not implemented\");\n    err.code = \"ENOSYS\";\n    return err;\n  };\n\n  if (!globalThis.fs) {\n    let outputBuf = \"\";\n    globalThis.fs = {\n      constants: {\n        O_WRONLY: -1,\n        O_RDWR: -1,\n        O_CREAT: -1,\n        O_TRUNC: -1,\n        O_APPEND: -1,\n        O_EXCL: -1\n      },\n\n      // unused\n      writeSync(fd, buf) {\n        outputBuf += decoder.decode(buf);\n        const nl = outputBuf.lastIndexOf(\"\\n\");\n\n        if (nl != -1) {\n          console.log(outputBuf.substr(0, nl));\n          outputBuf = outputBuf.substr(nl + 1);\n        }\n\n        return buf.length;\n      },\n\n      write(fd, buf, offset, length, position, callback) {\n        if (offset !== 0 || length !== buf.length || position !== null) {\n          callback(enosys());\n          return;\n        }\n\n        const n = this.writeSync(fd, buf);\n        callback(null, n);\n      },\n\n      chmod(path, mode, callback) {\n        callback(enosys());\n      },\n\n      chown(path, uid, gid, callback) {\n        callback(enosys());\n      },\n\n      close(fd, callback) {\n        callback(enosys());\n      },\n\n      fchmod(fd, mode, callback) {\n        callback(enosys());\n      },\n\n      fchown(fd, uid, gid, callback) {\n        callback(enosys());\n      },\n\n      fstat(fd, callback) {\n        callback(enosys());\n      },\n\n      fsync(fd, callback) {\n        callback(null);\n      },\n\n      ftruncate(fd, length, callback) {\n        callback(enosys());\n      },\n\n      lchown(path, uid, gid, callback) {\n        callback(enosys());\n      },\n\n      link(path, link, callback) {\n        callback(enosys());\n      },\n\n      lstat(path, callback) {\n        callback(enosys());\n      },\n\n      mkdir(path, perm, callback) {\n        callback(enosys());\n      },\n\n      open(path, flags, mode, callback) {\n        callback(enosys());\n      },\n\n      read(fd, buffer, offset, length, position, callback) {\n        callback(enosys());\n      },\n\n      readdir(path, callback) {\n        callback(enosys());\n      },\n\n      readlink(path, callback) {\n        callback(enosys());\n      },\n\n      rename(from, to, callback) {\n        callback(enosys());\n      },\n\n      rmdir(path, callback) {\n        callback(enosys());\n      },\n\n      stat(path, callback) {\n        callback(enosys());\n      },\n\n      symlink(path, link, callback) {\n        callback(enosys());\n      },\n\n      truncate(path, length, callback) {\n        callback(enosys());\n      },\n\n      unlink(path, callback) {\n        callback(enosys());\n      },\n\n      utimes(path, atime, mtime, callback) {\n        callback(enosys());\n      }\n\n    };\n  }\n\n  if (!globalThis.process) {\n    globalThis.process = {\n      getuid() {\n        return -1;\n      },\n\n      getgid() {\n        return -1;\n      },\n\n      geteuid() {\n        return -1;\n      },\n\n      getegid() {\n        return -1;\n      },\n\n      getgroups() {\n        throw enosys();\n      },\n\n      pid: -1,\n      ppid: -1,\n\n      umask() {\n        throw enosys();\n      },\n\n      cwd() {\n        throw enosys();\n      },\n\n      chdir() {\n        throw enosys();\n      }\n\n    };\n  }\n\n  if (!globalThis.crypto) {\n    throw new Error(\"globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)\");\n  }\n\n  if (!globalThis.performance) {\n    throw new Error(\"globalThis.performance is not available, polyfill required (performance.now only)\");\n  }\n\n  if (!globalThis.TextEncoder) {\n    throw new Error(\"globalThis.TextEncoder is not available, polyfill required\");\n  }\n\n  if (!globalThis.TextDecoder) {\n    throw new Error(\"globalThis.TextDecoder is not available, polyfill required\");\n  }\n\n  const encoder = new TextEncoder(\"utf-8\");\n  const decoder = new TextDecoder(\"utf-8\");\n  globalThis.Go = class {\n    constructor() {\n      this.argv = [\"js\"];\n      this.env = {};\n\n      this.exit = code => {\n        if (code !== 0) {\n          console.warn(\"exit code:\", code);\n        }\n      };\n\n      this._exitPromise = new Promise(resolve => {\n        this._resolveExitPromise = resolve;\n      });\n      this._pendingEvent = null;\n      this._scheduledTimeouts = new Map();\n      this._nextCallbackTimeoutID = 1;\n\n      const setInt64 = (addr, v) => {\n        this.mem.setUint32(addr + 0, v, true);\n        this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n      };\n\n      const getInt64 = addr => {\n        const low = this.mem.getUint32(addr + 0, true);\n        const high = this.mem.getInt32(addr + 4, true);\n        return low + high * 4294967296;\n      };\n\n      const loadValue = addr => {\n        const f = this.mem.getFloat64(addr, true);\n\n        if (f === 0) {\n          return undefined;\n        }\n\n        if (!isNaN(f)) {\n          return f;\n        }\n\n        const id = this.mem.getUint32(addr, true);\n        return this._values[id];\n      };\n\n      const storeValue = (addr, v) => {\n        const nanHead = 0x7FF80000;\n\n        if (typeof v === \"number\" && v !== 0) {\n          if (isNaN(v)) {\n            this.mem.setUint32(addr + 4, nanHead, true);\n            this.mem.setUint32(addr, 0, true);\n            return;\n          }\n\n          this.mem.setFloat64(addr, v, true);\n          return;\n        }\n\n        if (v === undefined) {\n          this.mem.setFloat64(addr, 0, true);\n          return;\n        }\n\n        let id = this._ids.get(v);\n\n        if (id === undefined) {\n          id = this._idPool.pop();\n\n          if (id === undefined) {\n            id = this._values.length;\n          }\n\n          this._values[id] = v;\n          this._goRefCounts[id] = 0;\n\n          this._ids.set(v, id);\n        }\n\n        this._goRefCounts[id]++;\n        let typeFlag = 0;\n\n        switch (typeof v) {\n          case \"object\":\n            if (v !== null) {\n              typeFlag = 1;\n            }\n\n            break;\n\n          case \"string\":\n            typeFlag = 2;\n            break;\n\n          case \"symbol\":\n            typeFlag = 3;\n            break;\n\n          case \"function\":\n            typeFlag = 4;\n            break;\n        }\n\n        this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n        this.mem.setUint32(addr, id, true);\n      };\n\n      const loadSlice = addr => {\n        const array = getInt64(addr + 0);\n        const len = getInt64(addr + 8);\n        return new Uint8Array(this._inst.exports.mem.buffer, array, len);\n      };\n\n      const loadSliceOfValues = addr => {\n        const array = getInt64(addr + 0);\n        const len = getInt64(addr + 8);\n        const a = new Array(len);\n\n        for (let i = 0; i < len; i++) {\n          a[i] = loadValue(array + i * 8);\n        }\n\n        return a;\n      };\n\n      const loadString = addr => {\n        const saddr = getInt64(addr + 0);\n        const len = getInt64(addr + 8);\n        return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n      };\n\n      const timeOrigin = Date.now() - performance.now();\n      this.importObject = {\n        go: {\n          // Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n          // may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n          // function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n          // This changes the SP, thus we have to update the SP used by the imported function.\n          // func wasmExit(code int32)\n          \"runtime.wasmExit\": sp => {\n            sp >>>= 0;\n            const code = this.mem.getInt32(sp + 8, true);\n            this.exited = true;\n            delete this._inst;\n            delete this._values;\n            delete this._goRefCounts;\n            delete this._ids;\n            delete this._idPool;\n            this.exit(code);\n          },\n          // func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n          \"runtime.wasmWrite\": sp => {\n            sp >>>= 0;\n            const fd = getInt64(sp + 8);\n            const p = getInt64(sp + 16);\n            const n = this.mem.getInt32(sp + 24, true);\n            fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n          },\n          // func resetMemoryDataView()\n          \"runtime.resetMemoryDataView\": sp => {\n            this.mem = new DataView(this._inst.exports.mem.buffer);\n          },\n          // func nanotime1() int64\n          \"runtime.nanotime1\": sp => {\n            sp >>>= 0;\n            setInt64(sp + 8, (timeOrigin + performance.now()) * 1000000);\n          },\n          // func walltime() (sec int64, nsec int32)\n          \"runtime.walltime\": sp => {\n            sp >>>= 0;\n            const msec = new Date().getTime();\n            setInt64(sp + 8, msec / 1000);\n            this.mem.setInt32(sp + 16, msec % 1000 * 1000000, true);\n          },\n          // func scheduleTimeoutEvent(delay int64) int32\n          \"runtime.scheduleTimeoutEvent\": sp => {\n            sp >>>= 0;\n            const id = this._nextCallbackTimeoutID;\n            this._nextCallbackTimeoutID++;\n\n            this._scheduledTimeouts.set(id, setTimeout(() => {\n              this._resume();\n\n              while (this._scheduledTimeouts.has(id)) {\n                // for some reason Go failed to register the timeout event, log and try again\n                // (temporary workaround for https://github.com/golang/go/issues/28975)\n                console.warn(\"scheduleTimeoutEvent: missed timeout event\");\n\n                this._resume();\n              }\n            }, getInt64(sp + 8) + 1 // setTimeout has been seen to fire up to 1 millisecond early\n            ));\n\n            this.mem.setInt32(sp + 16, id, true);\n          },\n          // func clearTimeoutEvent(id int32)\n          \"runtime.clearTimeoutEvent\": sp => {\n            sp >>>= 0;\n            const id = this.mem.getInt32(sp + 8, true);\n            clearTimeout(this._scheduledTimeouts.get(id));\n\n            this._scheduledTimeouts.delete(id);\n          },\n          // func getRandomData(r []byte)\n          \"runtime.getRandomData\": sp => {\n            sp >>>= 0;\n            crypto.getRandomValues(loadSlice(sp + 8));\n          },\n          // func finalizeRef(v ref)\n          \"syscall/js.finalizeRef\": sp => {\n            sp >>>= 0;\n            const id = this.mem.getUint32(sp + 8, true);\n            this._goRefCounts[id]--;\n\n            if (this._goRefCounts[id] === 0) {\n              const v = this._values[id];\n              this._values[id] = null;\n\n              this._ids.delete(v);\n\n              this._idPool.push(id);\n            }\n          },\n          // func stringVal(value string) ref\n          \"syscall/js.stringVal\": sp => {\n            sp >>>= 0;\n            storeValue(sp + 24, loadString(sp + 8));\n          },\n          // func valueGet(v ref, p string) ref\n          \"syscall/js.valueGet\": sp => {\n            sp >>>= 0;\n            const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n            sp = this._inst.exports.getsp() >>> 0; // see comment above\n\n            storeValue(sp + 32, result);\n          },\n          // func valueSet(v ref, p string, x ref)\n          \"syscall/js.valueSet\": sp => {\n            sp >>>= 0;\n            Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n          },\n          // func valueDelete(v ref, p string)\n          \"syscall/js.valueDelete\": sp => {\n            sp >>>= 0;\n            Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n          },\n          // func valueIndex(v ref, i int) ref\n          \"syscall/js.valueIndex\": sp => {\n            sp >>>= 0;\n            storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n          },\n          // valueSetIndex(v ref, i int, x ref)\n          \"syscall/js.valueSetIndex\": sp => {\n            sp >>>= 0;\n            Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n          },\n          // func valueCall(v ref, m string, args []ref) (ref, bool)\n          \"syscall/js.valueCall\": sp => {\n            sp >>>= 0;\n\n            try {\n              const v = loadValue(sp + 8);\n              const m = Reflect.get(v, loadString(sp + 16));\n              const args = loadSliceOfValues(sp + 32);\n              const result = Reflect.apply(m, v, args);\n              sp = this._inst.exports.getsp() >>> 0; // see comment above\n\n              storeValue(sp + 56, result);\n              this.mem.setUint8(sp + 64, 1);\n            } catch (err) {\n              sp = this._inst.exports.getsp() >>> 0; // see comment above\n\n              storeValue(sp + 56, err);\n              this.mem.setUint8(sp + 64, 0);\n            }\n          },\n          // func valueInvoke(v ref, args []ref) (ref, bool)\n          \"syscall/js.valueInvoke\": sp => {\n            sp >>>= 0;\n\n            try {\n              const v = loadValue(sp + 8);\n              const args = loadSliceOfValues(sp + 16);\n              const result = Reflect.apply(v, undefined, args);\n              sp = this._inst.exports.getsp() >>> 0; // see comment above\n\n              storeValue(sp + 40, result);\n              this.mem.setUint8(sp + 48, 1);\n            } catch (err) {\n              sp = this._inst.exports.getsp() >>> 0; // see comment above\n\n              storeValue(sp + 40, err);\n              this.mem.setUint8(sp + 48, 0);\n            }\n          },\n          // func valueNew(v ref, args []ref) (ref, bool)\n          \"syscall/js.valueNew\": sp => {\n            sp >>>= 0;\n\n            try {\n              const v = loadValue(sp + 8);\n              const args = loadSliceOfValues(sp + 16);\n              const result = Reflect.construct(v, args);\n              sp = this._inst.exports.getsp() >>> 0; // see comment above\n\n              storeValue(sp + 40, result);\n              this.mem.setUint8(sp + 48, 1);\n            } catch (err) {\n              sp = this._inst.exports.getsp() >>> 0; // see comment above\n\n              storeValue(sp + 40, err);\n              this.mem.setUint8(sp + 48, 0);\n            }\n          },\n          // func valueLength(v ref) int\n          \"syscall/js.valueLength\": sp => {\n            sp >>>= 0;\n            setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n          },\n          // valuePrepareString(v ref) (ref, int)\n          \"syscall/js.valuePrepareString\": sp => {\n            sp >>>= 0;\n            const str = encoder.encode(String(loadValue(sp + 8)));\n            storeValue(sp + 16, str);\n            setInt64(sp + 24, str.length);\n          },\n          // valueLoadString(v ref, b []byte)\n          \"syscall/js.valueLoadString\": sp => {\n            sp >>>= 0;\n            const str = loadValue(sp + 8);\n            loadSlice(sp + 16).set(str);\n          },\n          // func valueInstanceOf(v ref, t ref) bool\n          \"syscall/js.valueInstanceOf\": sp => {\n            sp >>>= 0;\n            this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);\n          },\n          // func copyBytesToGo(dst []byte, src ref) (int, bool)\n          \"syscall/js.copyBytesToGo\": sp => {\n            sp >>>= 0;\n            const dst = loadSlice(sp + 8);\n            const src = loadValue(sp + 32);\n\n            if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n              this.mem.setUint8(sp + 48, 0);\n              return;\n            }\n\n            const toCopy = src.subarray(0, dst.length);\n            dst.set(toCopy);\n            setInt64(sp + 40, toCopy.length);\n            this.mem.setUint8(sp + 48, 1);\n          },\n          // func copyBytesToJS(dst ref, src []byte) (int, bool)\n          \"syscall/js.copyBytesToJS\": sp => {\n            sp >>>= 0;\n            const dst = loadValue(sp + 8);\n            const src = loadSlice(sp + 16);\n\n            if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n              this.mem.setUint8(sp + 48, 0);\n              return;\n            }\n\n            const toCopy = src.subarray(0, dst.length);\n            dst.set(toCopy);\n            setInt64(sp + 40, toCopy.length);\n            this.mem.setUint8(sp + 48, 1);\n          },\n          \"debug\": value => {\n            console.log(value);\n          }\n        }\n      };\n    }\n\n    async run(instance) {\n      if (!(instance instanceof WebAssembly.Instance)) {\n        throw new Error(\"Go.run: WebAssembly.Instance expected\");\n      }\n\n      this._inst = instance;\n      this.mem = new DataView(this._inst.exports.mem.buffer);\n      this._values = [// JS values that Go currently has references to, indexed by reference id\n      NaN, 0, null, true, false, globalThis, this];\n      this._goRefCounts = new Array(this._values.length).fill(Infinity); // number of references that Go has to a JS value, indexed by reference id\n\n      this._ids = new Map([// mapping from JS values to reference ids\n      [0, 1], [null, 2], [true, 3], [false, 4], [globalThis, 5], [this, 6]]);\n      this._idPool = []; // unused ids that have been garbage collected\n\n      this.exited = false; // whether the Go program has exited\n      // Pass command line arguments and environment variables to WebAssembly by writing them to the linear memory.\n\n      let offset = 4096;\n\n      const strPtr = str => {\n        const ptr = offset;\n        const bytes = encoder.encode(str + \"\\0\");\n        new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n        offset += bytes.length;\n\n        if (offset % 8 !== 0) {\n          offset += 8 - offset % 8;\n        }\n\n        return ptr;\n      };\n\n      const argc = this.argv.length;\n      const argvPtrs = [];\n      this.argv.forEach(arg => {\n        argvPtrs.push(strPtr(arg));\n      });\n      argvPtrs.push(0);\n      const keys = Object.keys(this.env).sort();\n      keys.forEach(key => {\n        argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\n      });\n      argvPtrs.push(0);\n      const argv = offset;\n      argvPtrs.forEach(ptr => {\n        this.mem.setUint32(offset, ptr, true);\n        this.mem.setUint32(offset + 4, 0, true);\n        offset += 8;\n      }); // The linker guarantees global data starts from at least wasmMinDataAddr.\n      // Keep in sync with cmd/link/internal/ld/data.go:wasmMinDataAddr.\n\n      const wasmMinDataAddr = 4096 + 8192;\n\n      if (offset >= wasmMinDataAddr) {\n        throw new Error(\"total length of command line and environment variables exceeds limit\");\n      }\n\n      this._inst.exports.run(argc, argv);\n\n      if (this.exited) {\n        this._resolveExitPromise();\n      }\n\n      await this._exitPromise;\n    }\n\n    _resume() {\n      if (this.exited) {\n        throw new Error(\"Go program has already exited\");\n      }\n\n      this._inst.exports.resume();\n\n      if (this.exited) {\n        this._resolveExitPromise();\n      }\n    }\n\n    _makeFuncWrapper(id) {\n      const go = this;\n      return function () {\n        const event = {\n          id: id,\n          this: this,\n          args: arguments\n        };\n        go._pendingEvent = event;\n\n        go._resume();\n\n        return event.result;\n      };\n    }\n\n  };\n})();\n//# sourceMappingURL=bundle-aeb3ec41.js.map\n\n\n//# sourceURL=webpack://web-editor/./node_modules/@js-yamlfmt/wasm/esm/bundle-aeb3ec41.js?");

/***/ })

}]);